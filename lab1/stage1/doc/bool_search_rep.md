# 使用说明文档

本文档将介绍布尔查询程序的输入文件及其格式、如何处理布尔表达式，以及如何利用跳表（Skip List）优化查询性能。

## 输入文件及格式

程序需要以下输入文件：

1. **倒排索引表**

   - **书籍倒排索引表**：`book_inverted_index_table.csv`
   - **电影倒排索引表**：`movie_inverted_index_table.csv`

   **文件格式**：

   - CSV 文件，包含以下字段：
     - `word`：单词或词语。
     - `id_list`：包含该单词的文档 ID 列表，存储为字符串形式的列表，例如：`"[1, 2, 3]"`。
     - `skip_table`：跳表信息，存储为字符串形式的列表，包含跳跃节点的索引和对应的值，例如：`"[{'index': 2, 'value': 3}, {'index': 5, 'value': 6}]"`。

2. **全 ID 表**

   - **书籍 ID 表**：`Book_id.txt`
   - **电影 ID 表**：`Movie_id.txt`

   **文件格式**：

   - 文本文件，每行一个文档 ID，表示所有文档的集合。

3. **词表**

   - **书籍词表**：`book_words.csv`
   - **电影词表**：`movie_words.csv`

   **文件格式**：

   - CSV 文件，包含以下字段：
     - `id`：文档 ID。
     - `words`：文档的标签或关键字列表，存储为字符串形式的列表，例如：`"['爱情', '小说', '文学']"`。

## 处理布尔表达式

程序支持对文档进行布尔查询，支持的操作符包括：

- `AND`：逻辑与，表示取集合的交集。
- `OR`：逻辑或，表示取集合的并集。
- `NOT`：逻辑非，表示对集合取补集。
- 括号 `(` 和 `)`：用于改变运算的优先级。

**处理步骤如下**：

1. **分词**

   使用正则表达式将输入的布尔表达式拆分为标记（Token），包括操作数（单词）、操作符和括号。

   例如，输入表达式：

   ```
   (爱情 AND 小说) OR (NOT 科幻)
   ```

   分词结果为：

   ```python
   ['(', '爱情', 'AND', '小说', ')', 'OR', '(', 'NOT', '科幻', ')']
   ```

2. **中缀表达式转后缀表达式**

   为了方便计算机处理，将中缀表达式转换为后缀表达式（逆波兰表达式）。

   - 定义操作符的优先级：`NOT` > `AND` > `OR`。
   - 使用栈（Stack）来保存操作符，按照逆波兰表达式转换算法处理。

   转换后的后缀表达式为：

   ```python
   ['爱情', '小说', 'AND', '科幻', 'NOT', 'OR']
   ```

3. **后缀表达式求值**

   遍历后缀表达式，使用栈来计算结果集。

   - **遇到操作数**（单词）：
     - 从倒排索引表中获取对应的 `id_list` 和 `skip_table`，将二者作为一个元组压入栈中。
   - **遇到操作符**：
     - **`AND` 操作符**：
       - 从栈中弹出右操作数和左操作数（各包含 `id_list` 和 `skip_table`）。
       - 使用跳表优化的交集操作 `intersect_with_skips`，计算结果并压入栈中。
     - **`OR` 操作符**：
       - 从栈中弹出右操作数和左操作数。
       - 对两个 `id_list` 取并集，结果压入栈中。
     - **`NOT` 操作符**：
       - 从栈中弹出一个操作数。
       - 计算全 ID 集合与该操作数的差集，结果压入栈中。
   - 最终，栈顶元素即为查询结果的文档 ID 列表。

4. **结果展示**

   根据查询结果的文档 ID，从词表中查找对应的标签或关键字，打印输出。

## 利用跳表优化查询

在处理 `AND` 操作时，特别是当文档 ID 列表较长时，利用跳表可以加速查询过程，减少比较次数。

### 跳表（Skip List）原理

跳表是一种在有序链表上增加多级索引的结构，允许在查找时跳过部分元素，加速定位。

在倒排索引中，跳表由一系列跳跃节点组成，每个跳跃节点包含：

- `index`：在 `id_list` 中的索引位置。
- `value`：对应的文档 ID。

### 交集操作的优化

**传统交集操作**：

- 顺序遍历两个有序的文档 ID 列表，逐一比较，找到共同的文档 ID。
- 当列表很长时，比较次数多，效率较低。

**利用跳表的交集操作**：

- 在比较 `p1[i]` 和 `p2[j]` 时，如果 `p1[i] < p2[j]`，尝试利用 `p1` 的跳表跳过一些元素。
  - 查找 `p1` 中下一个跳跃节点，如果其值 `p1[next_skip_idx]` 小于等于 `p2[j]`，则将 `i` 直接跳到 `next_skip_idx`。
  - 否则，`i` 增加 1。
- 同理，如果 `p2[j] < p1[i]`，利用 `p2` 的跳表尝试跳过一些元素。
- 当 `p1[i] == p2[j]` 时，将该文档 ID 加入结果列表，`i` 和 `j` 均增加 1。

**算法步骤**：

```python
def intersect_with_skips(p1, p2, skip_p1, skip_p2):
    answer = []
    i = j = 0
    while i < len(p1) and j < len(p2):
        if p1[i] == p2[j]:
            answer.append(p1[i])
            i += 1
            j += 1
        elif p1[i] < p2[j]:
            next_skip_idx = get_next_skip_idx(skip_p1, i)
            if next_skip_idx != -1 and p1[next_skip_idx] <= p2[j]:
                i = next_skip_idx
            else:
                i += 1
        else:
            next_skip_idx = get_next_skip_idx(skip_p2, j)
            if next_skip_idx != -1 and p2[next_skip_idx] <= p1[i]:
                j = next_skip_idx
            else:
                j += 1
    return answer
```

**获取下一个跳跃索引**：

```python
def get_next_skip_idx(skip_table, current_idx):
    for skip in skip_table:
        if skip['index'] > current_idx:
            return skip['index']
    return -1
```

### 注意事项

- **跳表的构建**：
  - 跳表需要在构建倒排索引时生成，并存储在 `skip_table` 字段中。
  - 跳表的选择应根据列表长度和优化需求进行调整。

- **数据格式**：
  - 在读取倒排索引表时，确保正确解析 `id_list` 和 `skip_table`，并按照需要的数据结构存储。

- **性能提升**：
  - 利用跳表可以在处理长列表时显著减少比较次数，提高查询效率。
  - 对于较短的列表，跳表的效果可能不明显，但不会降低性能。

通过以上方法，程序能够高效地处理布尔查询，并利用跳表优化查询性能。